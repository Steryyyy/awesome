local a=require("my.gears.table")local b=nil;local c={}local unpack=unpack or table.unpack;function c.capi_index_fallback(d,e)e=e or{}local f=e.getter_prefix or"get_"local g=e.setter_prefix or"set_"local h=e.getter or function(i,j)if e.getter_class and e.getter_class[f..j]then return e.getter_class[f..j](i)elseif e.getter_class and e.getter_class["is_"..j]then return e.getter_class["is_"..j](i)end;if e.getter_class and e.getter_class[j]then return e.getter_class[j]end;if e.getter_fallback then return e.getter_fallback(i,j)end;assert(j~="_private")return i._private[j]end;local k=e.setter or function(i,j,l)if e.setter_class and e.setter_class[g..j]then return e.setter_class[g..j](i,l)end;if e.setter_fallback then return e.setter_fallback(i,j,l)end;if e.getter_class and e.getter_class[f..j]then return end;i._private[j]=l;if e.auto_emit then i:emit_signal("property::"..j,l)end end;assert(type(d)~="function")d.set_index_miss_handler(h)d.set_newindex_miss_handler(k)end;local function m(n)local o=n[1]local p=o and o._private and o._private._legacy_convert_to or nil;if not p then return nil end;local q={p}for r,s in ipairs(n)do assert(s._private and s._private._legacy_convert_to)if s._private._legacy_convert_to~=p then assert(s._private._legacy_convert_to)table.insert(q,s._private._legacy_convert_to)p=s._private._legacy_convert_to end end;return q end;local function t(u,v,w,x,y,z,A)local q=a.clone(v,false)return setmetatable(q,{__call=function(r,self,B)if not y then B,self=self,u end;local C=B and next(B)if B and C then local D=z(B)local E=D and B or a.join(unpack(B))local p=self["set_"..w]and m(E)or nil;if p then self["set_"..w](self,p)return x and self[x](self)or self[w]elseif x and y then return self[x](self,E)elseif x then return self[x](E)else self._private[w.."_formatted"]=E;return self._private[w.."_formatted"]end end;if x and y then return self[x](self)elseif x then return self[x]()else return self._private[w.."_formatted"]or{}end end})end;function c._legacy_accessors(u,w,x,y,z,A,F,G)F=F or G;local H=u.object and u.object or u;H["get_"..w]=function(self)self=y and self or u;self._private[w]=self._private[w]or t(u,{},w,x,y,z,A)local p=m(self._private[w])return p or self._private[w]end;H["set_"..w]=function(self,I)if not A and not next(I)then return end;if not y then I,self=self,u end;if I==false then I=nil end;if I==nil then I={}end;assert(self)local D=z(I)local function J()local E=D and I or a.join(unpack(I))if y and x then self[x](self,E)elseif x then u[x](E)else self._private[w.."_formatted"]=E end end;if not F then J()else if not self._private["_delayed_"..w]then b=b or require("my.gears.timer")b.delayed_call(function()self._private["_delayed_"..w]()self._private["_delayed_"..w]=nil end)end;self._private["_delayed_"..w]=J end;self._private[w]=t(u,I,w,x,y,z,A)end;if G then H["append_"..G]=function(self,K)self._private[w]=self._private[w]or H["get_"..w](self,nil)table.insert(self._private[w],K)H["set_"..w](self,self._private[w])end;H["remove_"..G]=function(self,K)self._private[w]=self._private[w]or H["get_"..w](self,nil)for L,M in ipairs(self._private[w])do if M==K then table.remove(self._private[w],L)break end end;H["set_"..w](self,self._private[w])end end end;return setmetatable(c,{__call=function(r,...)c.capi_index_fallback(...)end})